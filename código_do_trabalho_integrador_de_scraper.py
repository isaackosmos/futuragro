# -*- coding: utf-8 -*-
"""c√≥digo do trabalho integrador  de scraper.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1f4JdoCrSKeB-Uh8ylGsXbeTPcGUaFS6i
"""

# biblioteca para manipular e salvar dados
!pip install pandas
# biblioteca selenium para fazer requisi√ß√µes
!pip install selenium
# biblitoeca do webdriver para simular um navegador
!pip install webdriver-manager
# biblioteca beautifulsoup para fazer o parser
!pip install beautifulsoup4
# biblioteca para integrar enviar mensagens com um bot para o telegram
!pip install pytelegrambotapi

#importando as bibliotecas que ser√£o utilizadas
from selenium import webdriver
from selenium.webdriver.chrome.options import Options
from bs4 import BeautifulSoup
import pandas as pd
import os
import telebot

#configurando o webdriver para nao abrir uma janela (sem renderiza√ß√£o gr√°fica) e para desabilitar algumas configura√ß√µes padr√µes do naveagador
chrome_options = Options()
chrome_options.add_argument('--headless')
chrome_options.add_argument('--no-sandbox')
chrome_options.add_argument('--disble-dev-shm-usage')

# inicializa  o WebDriver
driver = webdriver.Chrome(options=chrome_options)

# FUN√á√ïES PARA A VARREDURA DE DADOS (WEB SCRAPING)

#
# Recebe uma lista de commodities e executa as a√ß√µes at√© salvar os dados em um Array
#
# Parametro: commoditiesList - Lista de commodities a ser percorridos
# Retorno: retorna uma lista com os dados das URL's
#
def handleWebSraping(commoditiesList):
  commoditiesData = []

  for commoditie in commoditiesList:
    fileName = getDataAndWriteXml(commoditie['url'], commoditie['name'])
    soup = getFileBeatifulSoup(fileName)
    commoditiesData = parseBeatifulSoupToDataList(soup, commoditiesData)

  return commoditiesData

#
# Acessa o link com o driver e escreve um arquivo XML
#
# Parametro: link - Link a ser acessado
# Parametro: fileName - Nome do arquivo
# Retorno: Nome que foi salvo o arquivo
#
def getDataAndWriteXml(link, name):
  driver.get(link)

  fileName = name + '.xml'

  with open(fileName, 'w') as file:
    file.write(driver.page_source)

  return fileName

#
# Busca o arquivo XML atrav√©s do seu nome e retorna um objeto BeautifulSoup
#
# Parametro: fileName - nome do arquivo XML
# Retorno: objeto BeautifulSoup
#
def getFileBeatifulSoup(fileName):
  file = open(fileName, 'r')
  soup = BeautifulSoup(file.read(), 'html.parser')
  file.close()

  return soup

#
# Faz o parser no objeto BeautifulSoup e salva os dados no Array
#
# Parametro: soup - Objeto BeautifulSoup a ser varrido
# Parametro: dataList - Lista onde os dados ser√£o salvos
# Retorno: retorna a lista com os dados varridos no objeto
#
def parseBeatifulSoupToDataList(soup, dataList):
  divHeader = soup.find("div", attrs={'class': 'modelo-header'})
  commoditieName = divHeader.find('h1').text

  lines = soup.find_all("tr")

  for line in lines[1:2]:
    date = line.find_all("td")[0].text
    price = line.find_all("td")[1].text
    range = line.find_all("td")[2].text

  dataList.append([commoditieName, date, price, range])

  return dataList

# FUN√á√ïES PARA EXPORTAR OS DADOS PARA CSV

#
# Executa todas as a√ß√µes necessarias para gerar o csv com os dados
#
# Parametro: commoditiesData - Lista com os varridos das commodities
# Parametro: csvFileName - Nome do arquivo csv a ser salvo
# Retorno: retorna o sucesso da opera√ß√£o
#
def handleExportToCsv(commoditiesData, csvFileName):
  if os.path.exists(csvFileName):
    return existentPathCsv(csvFileName, commoditiesData)

  return nonExistentPathCsv(csvFileName, commoditiesData)

#
# Executa o salvamento de dados em CSV para um path existente
#
# Parametro: csvFileName - Nome do arquivo CSV
# Parametro: commoditiesData - Dados atuais dos commodities
# Retorno: retorna o sucesso da opera√ß√£o
#
def existentPathCsv(csvFileName, commoditiesData):
  commoditiesCsv = pd.read_csv(csvFileName)

  date = commoditiesData[0][1]

  if date in commoditiesCsv['Fechamento'].values:
    return False

  commoditiesDataFrame = getCommoditiesDataFrame(commoditiesData)

  commoditiesCsv = pd.concat(
      [commoditiesCsv, commoditiesDataFrame],
      ignore_index=True,
  )

  return True

#
# Salva os dados em CSV para um path n√£o existente ainda
#
# Parametro: csvFileName - Nome do arquivo CSV
# Parametro: commoditiesData - Dados atuais dos commodities
# Retorno: retorna o sucesso da opera√ß√£o
#
def nonExistentPathCsv(csvFileName, commoditiesData):
  getCommoditiesDataFrame(commoditiesData).to_csv(csvFileName, index=False)

  return True

#
# Gera um dataFrame com os dados varridos das commodities
#
# Parametro: commoditiesData - Lista com os dados varridos
# Retorno: retorna o dataFrame da lista
#
def getCommoditiesDataFrame(commoditiesData):
  return pd.DataFrame(
      commoditiesData,
      columns=['Commodities', 'Fechamento', 'Pre√ßo', 'Variacao'],
  )

# FUN√á√ïES PARA O DISPARO DE MENSAGENS NO TELEGRAM

#
# Fun√ß√£o principal que executa todos os passos at√© o envio da mensagem
#
# Parametro: dataList - Lista contendo as informa√ß√µes das commodities
# Parametro: chatId - Id do chat do telegram
#
def handleTelegramMessage(dataList, chatId):
  message = mountTelegramMessage(dataList)
  sendMessageToTelegram(message, chatId)

#
# Monta a mensagem que ser√° disparada no Telegram
#
# Parametro: dataList - Lista contendo as informa√ß√µes das commodities
# Retorno: retorna a mensagem a ser disparada
#
def mountTelegramMessage(dataList):
  date = dataList[0][1]
  message = f"üåæ Fechamento de Pre√ßos de Commodities Agr√≠colas üåæ\n\n"
  message += f"Data: {date}\n\n"

  for commodity in dataList:
    commodityName = commodity[0]
    commodityPrice = float(commodity[2].replace(',', '.'))
    commodityRange = float(commodity[3].replace(',', '.').replace('%', ''))

    message += f"‚ÑπÔ∏è {commodityName}:\n"
    message += f"   Pre√ßo Atual: R$ {commodityPrice:.2f}\n"
    message += f"   Ajuste Di√°rio: {'+' if commodityRange >= 0 else '-'} {abs(commodityRange):.2f}%\n\n "

  return message

#
# Envia a mensagem para o chat informado
#
# Parametro: message - Mensagem a ser enviada
# Parametro: chatId - Id do chat do telegram
# Retorno: sem retorno
#
def sendMessageToTelegram(message, chatId):
  bot = telebot.TeleBot(BOT_TOKEN)
  bot.send_message(chat_id=chatId, text=message)

# Lista de URL's a serem percorridas e o nome de seus arquivos
commoditiesList = [
    {
        'url': 'https://www.noticiasagricolas.com.br/cotacoes/boi-gordo/boi-gordo-indicador-esalq-bmf',
        'name': 'boi'
    },
    {
        'url': 'https://www.noticiasagricolas.com.br/cotacoes/milho/indicador-cepea-esalq-milho',
        'name': 'milho'
    },
    {
        'url': 'https://www.noticiasagricolas.com.br/cotacoes/soja/soja-indicador-cepea-esalq-porto-paranagua',
        'name': 'soja'
    },
]

BOT_TOKEN = '7270884728:AAEWpIF6eRKRzTfl7QWNlPKeaUmNzCIhLWg'
GROUP_CHAT_ID = -1002238385511

#
# Fun√ß√£o princial, faz o webScraping completo
#
def main():
  csvFileName = 'commodities.csv'

  commoditiesData = handleWebSraping(commoditiesList)

  csvSuccess = handleExportToCsv(commoditiesData, csvFileName)

  if not csvSuccess:
    return

  handleTelegramMessage(commoditiesData, GROUP_CHAT_ID)

# chamando a fun√ß√£o main
main()